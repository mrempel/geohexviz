
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>geohexviz.builder &#8212; GeoHexViz 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for geohexviz.builder</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span> <span class="nn">fiona.errors</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">plotly.io</span> <span class="k">as</span> <span class="nn">pio</span>
<span class="kn">from</span> <span class="nn">geopandas</span> <span class="kn">import</span> <span class="n">GeoDataFrame</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">plotly.graph_objs</span> <span class="kn">import</span> <span class="n">Figure</span><span class="p">,</span> <span class="n">Choropleth</span><span class="p">,</span> <span class="n">Scattergeo</span><span class="p">,</span> <span class="n">Choroplethmapbox</span><span class="p">,</span> <span class="n">Scattermapbox</span>

<span class="kn">from</span> <span class="nn">geohexviz.templates</span> <span class="kn">import</span> <span class="n">get_template</span>
<span class="kn">from</span> <span class="nn">geohexviz.utils</span> <span class="kn">import</span> <span class="n">geoutils</span> <span class="k">as</span> <span class="n">gcg</span>
<span class="kn">from</span> <span class="nn">geohexviz.utils</span> <span class="kn">import</span> <span class="n">plot_util</span> <span class="k">as</span> <span class="n">butil</span>
<span class="kn">from</span> <span class="nn">geohexviz.utils.colorscales</span> <span class="kn">import</span> <span class="n">solid_scale</span><span class="p">,</span> <span class="n">discretize_cscale</span><span class="p">,</span> \
    <span class="n">get_scale</span>
<span class="kn">from</span> <span class="nn">geohexviz.utils.util</span> <span class="kn">import</span> <span class="n">fix_filepath</span><span class="p">,</span> <span class="n">get_column_type</span><span class="p">,</span> \
    <span class="n">simplify_dicts</span><span class="p">,</span> <span class="n">dict_deep_update</span><span class="p">,</span> <span class="n">get_percdiff</span><span class="p">,</span> <span class="n">parse_args_kwargs</span><span class="p">,</span> <span class="n">get_best</span><span class="p">,</span> <span class="n">get_worst</span>
<span class="kn">from</span> <span class="nn">geohexviz.errors</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">_read_method_mapping</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;geopandas&#39;</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">,</span>
    <span class="s1">&#39;csv&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">,</span>
    <span class="s1">&#39;shapefile&#39;</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">,</span>
    <span class="s1">&#39;excel&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span>
<span class="p">}</span>

<span class="n">_extension_mapping</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;.csv&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">,</span>
    <span class="s1">&#39;.xlsx&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">,</span>
    <span class="s1">&#39;.shp&#39;</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">,</span>
    <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span>
<span class="p">}</span>

<span class="n">_group_functions_short</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span>
    <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span>
    <span class="s1">&#39;avg&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span>
    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span>
    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span>
    <span class="s1">&#39;best&#39;</span><span class="p">:</span> <span class="n">get_best</span><span class="p">,</span>
    <span class="s1">&#39;worst&#39;</span><span class="p">:</span> <span class="n">get_worst</span>
<span class="p">}</span>

<span class="n">_group_functions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
    <span class="s1">&#39;occ&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
    <span class="s1">&#39;occurrences&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
    <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">],</span>
    <span class="s1">&#39;summation&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">],</span>
    <span class="s1">&#39;avg&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">],</span>
    <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">],</span>
    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span>
    <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span>
    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">],</span>
    <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">],</span>
    <span class="s1">&#39;best&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;best&#39;</span><span class="p">],</span>
    <span class="s1">&#39;best_option&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;best&#39;</span><span class="p">],</span>
    <span class="s1">&#39;mfreq&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;best&#39;</span><span class="p">],</span>
    <span class="s1">&#39;most_frequent&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;best&#39;</span><span class="p">],</span>
    <span class="s1">&#39;worst&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;worst&#39;</span><span class="p">],</span>
    <span class="s1">&#39;worst_option&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;worst&#39;</span><span class="p">],</span>
    <span class="s1">&#39;lfreq&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;worst&#39;</span><span class="p">],</span>
    <span class="s1">&#39;least_frequent&#39;</span><span class="p">:</span> <span class="n">_group_functions_short</span><span class="p">[</span><span class="s1">&#39;worst&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">StrDict</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="n">DFType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">GeoDataFrame</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_reset_to_odata</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">StrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resets the odata parameter of a layer.</span>

<span class="sd">    :param layer: The layer to reset</span>
<span class="sd">    :type layer: StrDict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_choropleth_trace</span><span class="p">(</span><span class="n">gdf</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">mapbox</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Choropleth</span><span class="p">,</span> <span class="n">Choroplethmapbox</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Prepares a choropleth trace for a geodataframe.</span>

<span class="sd">    :param gdf: The geodataframe to generate a choropleth trace for</span>
<span class="sd">    :type gdf: GeoDataFrame</span>
<span class="sd">    :param mapbox: Whether to return a mapbox trace or not</span>
<span class="sd">    :type mapbox: bool</span>
<span class="sd">    :return: The graph trace</span>
<span class="sd">    :rtype: Union[Choropleth, Choroplethmapbox]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">geojson</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">simple_geojson</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="s1">&#39;value_field&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mapbox</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Choroplethmapbox</span><span class="p">(</span>
            <span class="n">locations</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">],</span>
            <span class="n">geojson</span><span class="o">=</span><span class="n">geojson</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Choropleth</span><span class="p">(</span>
            <span class="n">locations</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">],</span>
            <span class="n">geojson</span><span class="o">=</span><span class="n">geojson</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_scattergeo_trace</span><span class="p">(</span><span class="n">gdf</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">separate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">disjoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mapbox</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> \
        <span class="n">Union</span><span class="p">[</span><span class="n">Scattergeo</span><span class="p">,</span> <span class="n">Scattermapbox</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Prepares a scattergeo trace for a geodataframe.</span>

<span class="sd">    :param gdf: The geodataframe to make a trace for</span>
<span class="sd">    :type gdf: GeoDataFrame</span>
<span class="sd">    :param separate: Whether to geometries within the geodataframe as separate or not</span>
<span class="sd">    :type separate: bool</span>
<span class="sd">    :param disjoint: Whether to add np.nan in between entries (plotly recognizes this as separate) or not</span>
<span class="sd">    :type disjoint: bool</span>
<span class="sd">    :param mapbox: Whether to return a mapbox trace or not</span>
<span class="sd">    :type mapbox: bool</span>
<span class="sd">    :return: The plotly graph trace</span>
<span class="sd">    :rtype: Union[Scattergeo, Scattermapbox]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">separate</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">polynum</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">polynum</span><span class="p">]</span>
            <span class="n">lats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="n">lons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">disjoint</span><span class="p">:</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">disjoint</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">disjoint</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">lats</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">lons</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mapbox</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Scattermapbox</span><span class="p">(</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">lons</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Scattergeo</span><span class="p">(</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">lons</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">StrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validates a layer.</span>

<span class="sd">    :param layer: The layer to validate</span>
<span class="sd">    :type layer: StrDict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be a &#39;data&#39; member present in the layer.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_reader_function_from_method</span><span class="p">(</span><span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_read_method_mapping</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input read method was not valid.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_reader_function_from_path</span><span class="p">(</span><span class="n">ext</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_extension_mapping</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input filepath had an incorrect extension,&quot;</span>
                         <span class="s2">&quot; this project only supports some types of files.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_data_file_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dpath</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataReadError</span><span class="p">(</span><span class="s2">&quot;There must be a &#39;path&#39; parameter&quot;</span>
                                <span class="s2">&quot; present when passing the &#39;data&#39; parameter as a dict.&quot;</span><span class="p">)</span>
        <span class="n">read_method</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">normal_errors</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;normal_errors&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">read_args</span><span class="p">,</span> <span class="n">read_kwargs</span> <span class="o">=</span> <span class="n">parse_args_kwargs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_read_data_file</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="n">read_method</span><span class="o">=</span><span class="n">read_method</span><span class="p">,</span>
                               <span class="n">read_args</span><span class="o">=</span><span class="n">read_args</span><span class="p">,</span> <span class="n">normal_errors</span><span class="o">=</span><span class="n">normal_errors</span><span class="p">,</span> <span class="o">**</span><span class="n">read_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_read_data_file</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_data_file</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">read_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Reads data from a file, based on extension.</span>

<span class="sd">    If the file extension is unknown the file is passed</span>
<span class="sd">    directly into geopandas.read_file().</span>

<span class="sd">    This function uses both geopandas and pandas to read data.</span>

<span class="sd">    In the future it may be beneficial to allow the reading</span>
<span class="sd">    of databases, and feather.</span>

<span class="sd">    :param data: The data to be read.</span>
<span class="sd">    :type data: str</span>
<span class="sd">    :return: The read data</span>
<span class="sd">    :rtype: DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">read_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">read_args</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">filepath</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="n">data</span><span class="p">))</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">fix_filepath</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">add_ext</span><span class="o">=</span><span class="n">extension</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">read_fn</span> <span class="o">=</span> <span class="n">get_reader_function_from_method</span><span class="p">(</span><span class="n">read_method</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">read_fn</span> <span class="o">=</span> <span class="n">get_reader_function_from_path</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">read_fn</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="o">*</span><span class="n">read_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataFileReadError</span><span class="p">(</span><span class="s2">&quot;The read function is not a callable object.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="s1">&#39;EPSG:4326&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="s1">&#39;EPSG:4326&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span> <span class="k">if</span> <span class="n">normal_errors</span> <span class="k">else</span> <span class="n">DataFileReadError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_read_data</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dstype</span><span class="p">:</span> <span class="n">LayerType</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeoDataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Reads the data into a usable type for the builder.</span>

<span class="sd">    :param data: The data to be read</span>
<span class="sd">    :type data: DFType</span>
<span class="sd">    :param allow_builtin: Whether to allow builtin data types or not (countries, continents)</span>
<span class="sd">    :type allow_builtin: bool</span>
<span class="sd">    :return: A proper geodataframe from the input data</span>
<span class="sd">    :rtype: GeoDataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rtype</span> <span class="o">=</span> <span class="s1">&#39;frame&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="n">_read_data_file_dict</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;file&#39;</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">DataFileReadError</span><span class="p">,</span> <span class="n">fiona</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">DriverError</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">allow_builtin</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="n">butil</span><span class="o">.</span><span class="n">get_shapes_from_world</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;builtin&#39;</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span> <span class="o">=</span> <span class="n">rtype</span>
        <span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span> <span class="o">=</span> <span class="s1">&#39;NUM&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DataReadError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_parse_latlong_fields</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dstype</span><span class="p">:</span> <span class="n">LayerType</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span>
                          <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Parses the lat/long columns from a GeoDataFrame (called upon loading).</span>

<span class="sd">    :param data: The data to parse columns from</span>
<span class="sd">    :type data: GeoDataFrame</span>
<span class="sd">    :param latitude_field: The name of the latitude column (or none)</span>
<span class="sd">    :type latitude_field: str</span>
<span class="sd">    :param longitude_field: The name of the longitude column (or none)</span>
<span class="sd">    :type longitude_field: str</span>
<span class="sd">    :return: The two columns if applicable (or none, none)</span>
<span class="sd">    :rtype: Tuple[pd.Series, pd.Series]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;geometry&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">latitude_field</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">longitude_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">latitude_field</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">latitude_field</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">latitude_aliases</span><span class="p">:</span>
                <span class="n">latitude_field</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">latitude_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GeometryParseLatLongError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">longitude_field</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">longitude_field</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">longitude_aliases</span><span class="p">:</span>
                <span class="n">longitude_field</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">longitude_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GeometryParseLatLongError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">get_column_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">latitude_field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;NUM&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">latitude_field</span> <span class="o">=</span> <span class="n">latitude_field</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">LatLongParseTypeError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">get_column_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">longitude_field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;NUM&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">longitude_field</span> <span class="o">=</span> <span class="n">longitude_field</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">LatLongParseTypeError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">latitude_field</span><span class="p">,</span> <span class="n">longitude_field</span>


<span class="k">def</span> <span class="nf">_convert_latlong_data</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dstype</span><span class="p">:</span> <span class="n">LayerType</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span>
                          <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeoDataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Converts lat/long columns into a proper geometry column, if present.</span>

<span class="sd">    :param data: The data that may or may not contain lat/long columns</span>
<span class="sd">    :type data: GeoDataFrame</span>
<span class="sd">    :param latitude_field: The latitude column within the dataframe</span>
<span class="sd">    :type latitude_field: str</span>
<span class="sd">    :param longitude_field: The longitude column within the dataframe</span>
<span class="sd">    :type longitude_field: str</span>
<span class="sd">    :return: The converted dataframe</span>
<span class="sd">    :rtype: GeoDataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DataEmptyError</span><span class="p">(</span><span class="s2">&quot;If the data passed is a DataFrame/GeoDataFrame, it must not be empty.&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">latitude_field</span><span class="p">,</span> <span class="n">longitude_field</span> <span class="o">=</span> <span class="n">_parse_latlong_fields</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span> <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">longitude_field</span><span class="p">,</span> <span class="n">latitude_field</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s1">&#39;EPSG:4326&#39;</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># TODO: test this with empty dataframes</span>
    <span class="c1"># removes empty latitude and longitude entries that cause errors in the final product</span>
    <span class="k">if</span> <span class="n">latitude_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">longitude_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">latitude_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">longitude_field</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">gcg</span><span class="o">.</span><span class="n">conform_geogeometry</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">vtype</span> <span class="o">=</span> <span class="s1">&#39;NUM&#39;</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_convert_to_hexbin_data</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dstype</span><span class="p">:</span> <span class="n">LayerType</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">hex_resolution</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">binning_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">binning_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">binning_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeoDataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Converts a geodataframe into a hexagon-ally binned dataframe.</span>

<span class="sd">    :param data: The data to be converted</span>
<span class="sd">    :type data: GeoDataFrame</span>
<span class="sd">    :param hex_resolution: The hexagonal resolution to use</span>
<span class="sd">    :type hex_resolution: int</span>
<span class="sd">    :param binning_args: Arguments for the binning functions</span>
<span class="sd">    :type binning_args: Iterable</span>
<span class="sd">    :param binning_field: The binning column to apply the function on</span>
<span class="sd">    :type binning_field: str</span>
<span class="sd">    :param binning_fn: The function to apply</span>
<span class="sd">    :type binning_fn: Callable</span>
<span class="sd">    :param kwargs: Keyword arguments for the function</span>
<span class="sd">    :type kwargs: **kwargs</span>
<span class="sd">    :return: The hexbinified dataframe</span>
<span class="sd">    :rtype: GeoDataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bfield_passed</span> <span class="o">=</span> <span class="n">binning_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_hexify_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hex_resolution</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning_fn</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">binning_fn</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fn&#39;</span><span class="p">,</span> <span class="n">binning_fn</span><span class="p">)</span>
        <span class="n">binning_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">parse_args_kwargs</span><span class="p">(</span><span class="n">binning_fn</span><span class="p">,</span> <span class="n">default_args</span><span class="o">=</span><span class="n">binning_args</span><span class="p">,</span> <span class="n">default_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">binning_fn</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">binning_fn</span> <span class="o">=</span> <span class="n">_group_functions</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">binning_fn</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">vtype</span> <span class="o">=</span> <span class="s1">&#39;NUM&#39;</span> <span class="k">if</span> <span class="n">binning_field</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">get_column_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binning_field</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vtype</span> <span class="o">==</span> <span class="s1">&#39;UNK&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BinValueTypeError</span><span class="p">(</span><span class="s2">&quot;An invalid binning column was passed.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;The binning field must be string or numerical column.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vtype</span> <span class="o">==</span> <span class="s1">&#39;STR&#39;</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">binning_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">binning_field</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">binning_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">binning_fn</span> <span class="o">=</span> <span class="n">_group_functions</span><span class="p">[</span><span class="s1">&#39;best&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">vtype</span> <span class="o">==</span> <span class="s1">&#39;STR&#39;</span> <span class="k">else</span>\
            <span class="p">(</span><span class="n">_group_functions</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">bfield_passed</span> <span class="k">else</span> <span class="n">_group_functions</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">])</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">bin_by_hexid</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binning_field</span><span class="o">=</span><span class="n">binning_field</span><span class="p">,</span> <span class="n">binning_fn</span><span class="o">=</span><span class="n">binning_fn</span><span class="p">,</span> <span class="n">binning_args</span><span class="o">=</span><span class="n">binning_args</span><span class="p">,</span>
                            <span class="n">result_name</span><span class="o">=</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="n">add_geoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">vtype</span> <span class="o">=</span> <span class="n">get_column_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;value_field&#39;</span><span class="p">)</span>

    <span class="c1"># if the resulting column is of unknown type, the binning function did not produce a viable result</span>
    <span class="k">if</span> <span class="n">vtype</span> <span class="o">==</span> <span class="s1">&#39;UNK&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BinValueTypeError</span><span class="p">(</span><span class="s2">&quot;The result of the binning operation was invalid.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;The binning operation must produce a column that contains either string, or numbers.&quot;</span><span class="p">)</span>
    <span class="n">gcg</span><span class="o">.</span><span class="n">conform_geogeometry</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span> <span class="o">=</span> <span class="n">vtype</span>

    <span class="c1"># if there is no data after the above process, there was no grid generated</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NoHexagonalTilingError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">StrDict</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Updates the manager of a given layer.</span>

<span class="sd">    :param layer: The layer whose manager to update</span>
<span class="sd">    :type layer: StrDict</span>
<span class="sd">    :param updates: A dict of updates for the manager</span>
<span class="sd">    :type updates: StrDict</span>
<span class="sd">    :param overwrite: Whether to overwrite the existing manager with the new one or not</span>
<span class="sd">    :type overwrite: bool</span>
<span class="sd">    :param kwargs: Extra updates for the manager</span>
<span class="sd">    :type kwargs: **kwargs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">updates</span> <span class="o">=</span> <span class="n">simplify_dicts</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updates</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dict_deep_update</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">],</span> <span class="n">updates</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_hexify_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">GeoDataFrame</span><span class="p">],</span> <span class="n">hex_resolution</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">GeoDataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for hexifying a geodataframe</span>

<span class="sd">    :param data: The geodataframe to hexify</span>
<span class="sd">    :type data: Union[DataFrame, GeoDataFrame]</span>
<span class="sd">    :param hex_resolution: The hexagonal resolution to use</span>
<span class="sd">    :type hex_resolution: int</span>
<span class="sd">    :return: The hexified geodataframe</span>
<span class="sd">    :rtype: Union[DataFrame, GeoDataFrame]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gcg</span><span class="o">.</span><span class="n">hexify_dataframe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hex_resolution</span><span class="o">=</span><span class="n">hex_resolution</span><span class="p">,</span> <span class="n">add_geom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_geom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split_query</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Splits a query into the layer type and layer name.</span>

<span class="sd">    :param query: The query to split</span>
<span class="sd">    :type query: str</span>
<span class="sd">    :return: The split query (type, name)</span>
<span class="sd">    :rtype: Tuple[str, str]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lind</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">[:</span><span class="n">lind</span><span class="p">],</span> <span class="n">query</span><span class="p">[</span><span class="n">lind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">_check_name</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dstype</span><span class="p">:</span> <span class="n">LayerType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if the given layer name is valid, and throws an error if it is not.</span>

<span class="sd">    :param name: The name of the layer</span>
<span class="sd">    :type name: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">LayerNamingError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dstype</span><span class="p">,</span> <span class="s2">&quot;Non-alphanumeric found (besides underscores)&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="PlotStatus"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotStatus">[docs]</a><span class="k">class</span> <span class="nc">PlotStatus</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An enumeration of different plot status.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DATA_PRESENT</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">NO_DATA</span> <span class="o">=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="PlotBuilder"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder">[docs]</a><span class="k">class</span> <span class="nc">PlotBuilder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This class contains a Builder implementation for visualizing Plotly Hex data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hexbin_layer</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">regions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">grids</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outlines</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">points</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_templates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializer for instances of PlotBuilder.</span>

<span class="sd">        Initializes a new PlotBuilder with the given main layer</span>
<span class="sd">        alongside any region, grid, outline, point type layers.</span>

<span class="sd">        :param hexbin_layer: The main layer for this builder</span>
<span class="sd">        :type hexbin_layer: StrDict</span>
<span class="sd">        :param regions: A set of region-type layers for this builder</span>
<span class="sd">        :type regions: Dict[str, StrDict]</span>
<span class="sd">        :param grids: A sed of grid-type layers for this builder</span>
<span class="sd">        :type grids: Dict[str, StrDict]</span>
<span class="sd">        :param outlines: A set of outline-type layers for this builder</span>
<span class="sd">        :type outlines: Dict[str, StrDict]</span>
<span class="sd">        :param points: A set of point-type layers for this builder</span>
<span class="sd">        :type points: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">NO_DATA</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_templates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;figure&#39;</span><span class="p">))</span>
            <span class="c1"># grids will all reference this manager</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span> <span class="o">=</span> <span class="n">use_templates</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;regions&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;grids&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;outlines&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="p">{}</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_output_service</span> <span class="o">=</span> <span class="s1">&#39;plotly&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_hex_resolution</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_destination</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_output_location</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># for future use</span>

        <span class="k">if</span> <span class="n">hexbin_layer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_hexbin</span><span class="p">(</span><span class="o">**</span><span class="n">hexbin_layer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">regions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_region</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_grid</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outlines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">outlines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_outline</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_point</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot_output_service</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the current plot output service for the builder.</span>

<span class="sd">        :return: The current plot output service</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plot_output_service</span><span class="p">()</span>

    <span class="nd">@plot_output_service</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">plot_output_service</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">service</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the plot output service for this builder.</span>

<span class="sd">        :param service: The output service (one of &#39;plotly&#39;, &#39;mapbox&#39;)</span>
<span class="sd">        :type service: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_plot_output_service</span><span class="p">(</span><span class="n">service</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_plot_output_service"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_plot_output_service">[docs]</a>    <span class="k">def</span> <span class="nf">get_plot_output_service</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the current plot output service for the builder.</span>

<span class="sd">        :return: The current plot output service</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_service</span></div>

<div class="viewcode-block" id="PlotBuilder.set_plot_output_service"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.set_plot_output_service">[docs]</a>    <span class="k">def</span> <span class="nf">set_plot_output_service</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">service</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the plot output service for this builder.</span>

<span class="sd">        :param service: The output service (one of &#39;plotly&#39;, &#39;mapbox&#39;)</span>
<span class="sd">        :type service: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">service</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;plotly&#39;</span><span class="p">,</span> <span class="s1">&#39;mapbox&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The output service must be one of [&#39;plotly&#39;, &#39;mapbox&#39;].&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_service</span> <span class="o">=</span> <span class="n">service</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;getitem method works like search method.</span>

<span class="sd">        :param item: The item to search for</span>
<span class="sd">        :type item: str</span>
<span class="sd">        :return: The retrieved layer(s)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MAIN layer FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.set_hexbin"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.set_hexbin">[docs]</a>    <span class="k">def</span> <span class="nf">set_hexbin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span>
            <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">hex_resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">hexbin_info</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">manager</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the hexbin layer to plot.</span>

<span class="sd">        :param data: The data for this set</span>
<span class="sd">        :type data: DFType</span>
<span class="sd">        :param latitude_field: The latitude column of the data</span>
<span class="sd">        :type latitude_field: str</span>
<span class="sd">        :param longitude_field: The longitude column of the data</span>
<span class="sd">        :type longitude_field: str</span>
<span class="sd">        :param hex_resolution: The hex resolution to use (this can also be passed via hexbin_info)</span>
<span class="sd">        :type hex_resolution: int</span>
<span class="sd">        :param hexbin_info: A container for properties pertaining to hexagonal binning</span>
<span class="sd">        :type hexbin_info: StrDict</span>
<span class="sd">        :param manager: A container for the plotly properties for this layer</span>
<span class="sd">        :type manager: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;|*EMPTY*|&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hexbin_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hexbin_info</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">selected_res</span> <span class="o">=</span> <span class="p">(</span><span class="n">hex_resolution</span> <span class="ow">or</span> <span class="n">hexbin_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hex_resolution&#39;</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_hex_resolution</span>
        <span class="n">hbin_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">hex_resolution</span><span class="o">=</span><span class="n">selected_res</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="s1">&#39;hexbin&#39;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">NAME</span><span class="o">=</span><span class="s1">&#39;HEXBIN&#39;</span><span class="p">,</span> <span class="n">RTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span><span class="p">,</span> <span class="n">DSTYPE</span><span class="o">=</span><span class="s1">&#39;HEX&#39;</span><span class="p">,</span> <span class="n">HRES</span><span class="o">=</span><span class="n">selected_res</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_latlong_data</span><span class="p">(</span><span class="s1">&#39;hexbin&#39;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                                     <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span> <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)</span>

        <span class="n">hbin_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">hexbin_info</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_to_hexbin_data</span><span class="p">(</span><span class="s2">&quot;hexbin&quot;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">hbin_info</span><span class="p">)</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;VTYPE&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;VTYPE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NUM&#39;</span><span class="p">:</span>
                <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;main_quant&#39;</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;main_qual&#39;</span><span class="p">)))</span>
        <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">manager</span> <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;hexbin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

    <span class="k">def</span> <span class="nf">_get_hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the main layer.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :return: The main layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;hexbin&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="s2">&quot;hexbin&quot;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_hexbin"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_hexbin">[docs]</a>    <span class="k">def</span> <span class="nf">get_hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the main layer.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :return: The main layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">())</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_hexbin"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_hexbin">[docs]</a>    <span class="k">def</span> <span class="nf">remove_hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes the main layer.</span>

<span class="sd">        :param pop: Whether or not to return the removed layer</span>
<span class="sd">        :type pop: bool</span>
<span class="sd">        :return: The removed layer (pop=True)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hexbin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hexbin&#39;</span><span class="p">)</span>

            <span class="c1"># remove the empty grid that may or may not have been added</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_grid</span><span class="p">(</span><span class="s1">&#39;|*EMPTY*|&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NoLayerError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hexbin</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="s2">&quot;hexbin&quot;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.update_hexbin_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_hexbin_manager">[docs]</a>    <span class="k">def</span> <span class="nf">update_hexbin_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the manager the hexbin layer.</span>

<span class="sd">        :param updates: A dict containing updates for the layer(s)</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether to override the current properties with the new ones or not</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Other updates for the layer(s)</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_update_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">(),</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_hexbin_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_hexbin_manager">[docs]</a>    <span class="k">def</span> <span class="nf">clear_hexbin_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the manager of the hexbin layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="s2">&quot;hexbin&quot;</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">HEXBIN</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_hexbin_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_hexbin_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_hexbin_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the data within the hexbin layer to the data that was input at the beginning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_reset_to_odata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">())</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    REGION FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.add_region"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.add_region">[docs]</a>    <span class="k">def</span> <span class="nf">add_region</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span>
            <span class="n">manager</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a region-type layer to the builder.</span>

<span class="sd">        Region-type layers should consist of Polygon-like geometries.</span>
<span class="sd">        Best results are read from a GeoDataFrame, or DataFrame.</span>

<span class="sd">        :param name: The name this layer is to be stored with</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: The location of the data for this layer</span>
<span class="sd">        :type data: Union[str, DataFrame, GeoDataFrame]</span>
<span class="sd">        :param manager: The plotly properties for this layer.</span>
<span class="sd">        :type manager: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">REGION</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">REGION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">NAME</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">RTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span><span class="p">,</span> <span class="n">DSTYPE</span><span class="o">=</span><span class="s1">&#39;RGN&#39;</span><span class="p">,</span> <span class="n">VTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">manager</span> <span class="ow">or</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

    <span class="k">def</span> <span class="nf">_get_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a region layer from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">REGION</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_region"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a region layer from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_region</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the region layers from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;regions&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="PlotBuilder.get_regions"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_regions">[docs]</a>    <span class="k">def</span> <span class="nf">get_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the region layers from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">())</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_region"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_region">[docs]</a>    <span class="k">def</span> <span class="nf">remove_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes a region layer from the builder.</span>

<span class="sd">        :param name: The name of the layer to remove</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param pop: Whether to return the removed layer or not</span>
<span class="sd">        :type pop: bool</span>
<span class="sd">        :return: The removed layer (pop=True)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">region</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">REGION</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.update_region_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_region_manager">[docs]</a>    <span class="k">def</span> <span class="nf">update_region_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the manager of a region or regions.</span>

<span class="sd">        The manager consists of Plotly properties.</span>
<span class="sd">        If the given name is none, all region layers will be updated.</span>

<span class="sd">        :param name: The name of the layer to update</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param updates: A dict containing updates for the layer(s)</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether to override the current properties with the new ones or not</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Other updates for the layer(s)</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_update_manager</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_update_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_region</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_region_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_region_manager">[docs]</a>    <span class="k">def</span> <span class="nf">clear_region_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the manager of a region layer.</span>

<span class="sd">        If the given name is none, clears all of the region managers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_region_manager</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="p">{},</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_region_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_region_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_region_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the data within the region layer to the data that was input at the beginning.</span>

<span class="sd">        If the given name is None, all region layers will be reset.</span>

<span class="sd">        :param name: The name of the layer to reset</span>
<span class="sd">        :type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_reset_to_odata</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_reset_to_odata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_region</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_regions"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_regions">[docs]</a>    <span class="k">def</span> <span class="nf">reset_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the regions within the builder to empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GRID FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.add_grid"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.add_grid">[docs]</a>    <span class="k">def</span> <span class="nf">add_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span>
            <span class="n">hex_resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">convex_simplify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a grid-type layer to the builder.</span>

<span class="sd">        Grid-type layers should consist of Polygon-like or Point-like geometries.</span>

<span class="sd">        :param name: The name this layer is to be stored with</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: The location of the data for this layer</span>
<span class="sd">        :type data: Union[str, DataFrame, GeoDataFrame]</span>
<span class="sd">        :param hex_resolution: The hexagonal resolution to use for this layer (None-&gt;builder default)</span>
<span class="sd">        :type hex_resolution: int</span>
<span class="sd">        :param latitude_field: The latitude column within the data</span>
<span class="sd">        :type latitude_field: str</span>
<span class="sd">        :param longitude_field: The longitude column within the data</span>
<span class="sd">        :type longitude_field: str</span>
<span class="sd">        :param convex_simplify: Determines if the area the grid is to be placed over should be simplified or not</span>
<span class="sd">        :type convex_simplify: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hex_resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hex_resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()[</span><span class="s1">&#39;HRES&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">NoLayerError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">selected_res</span> <span class="o">=</span> <span class="n">hex_resolution</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_hex_resolution</span>

        <span class="n">_check_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">NAME</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">RTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span><span class="p">,</span> <span class="n">DSTYPE</span><span class="o">=</span><span class="s1">&#39;GRD&#39;</span><span class="p">,</span> <span class="n">VTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span><span class="p">,</span> <span class="n">HRES</span><span class="o">=</span><span class="n">selected_res</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_latlong_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                                     <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span> <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">convex_simplify</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_to_hexbin_data</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">hex_resolution</span><span class="o">=</span><span class="n">selected_res</span><span class="p">,</span>
            <span class="n">binning_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

    <span class="k">def</span> <span class="nf">_get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a grid layer from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_grid"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a grid layer from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_grid</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the grid layers from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;grids&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="PlotBuilder.get_grids"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_grids">[docs]</a>    <span class="k">def</span> <span class="nf">get_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the grid layers from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">())</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_grid"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_grid">[docs]</a>    <span class="k">def</span> <span class="nf">remove_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes a grid layer from the builder.</span>

<span class="sd">        :param name: The name of the layer to remove</span>
<span class="sd">        :type name:</span>
<span class="sd">        :param pop: Whether to return the removed layer or not</span>
<span class="sd">        :type pop: bool</span>
<span class="sd">        :return: The removed layer (pop=True)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset_grids</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">grid</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.update_grid_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_grid_manager">[docs]</a>    <span class="k">def</span> <span class="nf">update_grid_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the general grid manager.</span>

<span class="sd">        :param updates: A dict of updates for the manager</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether or not to override existing manager properties</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Any additional updates for the manager</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">():</span>
            <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;manager&#39;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="p">)}</span>
            <span class="n">_update_manager</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_grid_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_grid_manager">[docs]</a>    <span class="k">def</span> <span class="nf">clear_grid_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the manager of a region layer.</span>

<span class="sd">        If the given name is none, clears all of the region managers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_grid_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_grid_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_grid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the data within the grid layer to the data that was input at the beginning.</span>

<span class="sd">        If the given name is None, all grid layers will be reset.</span>

<span class="sd">        :param name: The name of the layer to reset</span>
<span class="sd">        :type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_reset_to_odata</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_reset_to_odata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_grid</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_grids"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_grids">[docs]</a>    <span class="k">def</span> <span class="nf">reset_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the grid layer container to it&#39;s original state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;grids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_grid_manager</span><span class="p">()</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OUTLINE FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.add_outline"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.add_outline">[docs]</a>    <span class="k">def</span> <span class="nf">add_outline</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span>
            <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">as_boundary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">manager</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a outline-type layer to the builder.</span>

<span class="sd">        :param name: The name this layer is to be stored with</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: The location of the data for this layer</span>
<span class="sd">        :type data: Union[str, DataFrame, GeoDataFrame]</span>
<span class="sd">        :param latitude_field: The latitude column of the data</span>
<span class="sd">        :type latitude_field: str</span>
<span class="sd">        :param longitude_field: The longitude column of the data</span>
<span class="sd">        :type longitude_field: str</span>
<span class="sd">        :param as_boundary: Changes the data into one big boundary if true</span>
<span class="sd">        :type as_boundary: bool</span>
<span class="sd">        :param manager: Plotly properties for this layer</span>
<span class="sd">        :type manager: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">NAME</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">RTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span><span class="p">,</span> <span class="n">DSTYPE</span><span class="o">=</span><span class="s1">&#39;OUT&#39;</span><span class="p">,</span> <span class="n">VTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_latlong_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span>
                                     <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)[[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
        <span class="c1"># TODO: there exists errors with the representation of outlines (given lfields)</span>

        <span class="k">if</span> <span class="n">as_boundary</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">unify_geodataframe</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;outline&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">manager</span> <span class="ow">or</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

    <span class="k">def</span> <span class="nf">_get_outline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a outline layer from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_outline"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_outline">[docs]</a>    <span class="k">def</span> <span class="nf">get_outline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a outline layer from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_outline</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_outlines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the outline layers from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;outlines&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="PlotBuilder.get_outlines"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_outlines">[docs]</a>    <span class="k">def</span> <span class="nf">get_outlines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the outline layers from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :return: The retrieved layers</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">())</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_outline"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_outline">[docs]</a>    <span class="k">def</span> <span class="nf">remove_outline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes an outline layer from the builder.</span>

<span class="sd">        :param name: The name of the layer to remove</span>
<span class="sd">        :type name:</span>
<span class="sd">        :param pop: Whether to return the removed layer or not</span>
<span class="sd">        :type pop: bool</span>
<span class="sd">        :return: The removed layer (pop=True)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outline</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.update_outline_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_outline_manager">[docs]</a>    <span class="k">def</span> <span class="nf">update_outline_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the manager of a outline or outlines.</span>

<span class="sd">        The manager consists of Plotly properties.</span>
<span class="sd">        If the given name is none, all outline layers will be updated.</span>

<span class="sd">        :param name: The name of the layer to update</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param updates: A dict containing updates for the layer(s)</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether to override the current properties with the new ones or not</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Other updates for the layer(s)</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_update_manager</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_update_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_outline</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_outline_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_outline_manager">[docs]</a>    <span class="k">def</span> <span class="nf">clear_outline_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the manager of a outline layer.</span>

<span class="sd">        If the given name is none, clears all of the outline managers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_outline_manager</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="p">{},</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_outline_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_outline_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_outline_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the data within the outline layer to the data that was input at the beginning.</span>

<span class="sd">        If the given name is None, all outline layers will be reset.</span>

<span class="sd">        :param name: The name of the layer to reset</span>
<span class="sd">        :type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_reset_to_odata</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_reset_to_odata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_outline</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_outlines"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_outlines">[docs]</a>    <span class="k">def</span> <span class="nf">reset_outlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the outlines within the builder to empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;outlines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    POINT FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.add_point"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.add_point">[docs]</a>    <span class="k">def</span> <span class="nf">add_point</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">DFType</span><span class="p">,</span>
            <span class="n">latitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">longitude_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">text_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">manager</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a point-type layer to the builder.</span>

<span class="sd">        Ideally the layer&#39;s &#39;data&#39; member should contain</span>
<span class="sd">        lat/long columns or point like geometry column. If the geometry column</span>
<span class="sd">        is present and contains no point like geometry, the geometry will be converted</span>
<span class="sd">        into a bunch of points.</span>

<span class="sd">        :param name: The name this layer is to be stored with</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param data: The location of the data for this layer</span>
<span class="sd">        :type data: Union[str, DataFrame, GeoDataFrame]</span>
<span class="sd">        :param latitude_field: The latitude column of the data</span>
<span class="sd">        :type latitude_field: str</span>
<span class="sd">        :param longitude_field: The longitude column of the data</span>
<span class="sd">        :type longitude_field: str</span>
<span class="sd">        :param text_field: The column containing text for data entries</span>
<span class="sd">        :type text_field: str</span>
<span class="sd">        :param manager: Plotly properties for this layer</span>
<span class="sd">        :type manager: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_check_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">allow_builtin</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">NAME</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">RTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">RTYPE</span><span class="p">,</span> <span class="n">DSTYPE</span><span class="o">=</span><span class="s1">&#39;PNT&#39;</span><span class="p">,</span> <span class="n">VTYPE</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">VTYPE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text_field</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_latlong_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span>
                                         <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)[[</span><span class="n">text_field</span><span class="p">,</span> <span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_latlong_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">latitude_field</span><span class="o">=</span><span class="n">latitude_field</span><span class="p">,</span>
                                         <span class="n">longitude_field</span><span class="o">=</span><span class="n">longitude_field</span><span class="p">)[[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;tfield&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text_field</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;point&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">manager</span> <span class="ow">or</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

    <span class="k">def</span> <span class="nf">_get_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a point layer from the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.get_point"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a point layer from the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :param name: The name of the layer</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The retrieved layer</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_point</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the collection of point layers in the builder.</span>

<span class="sd">        Internal version.</span>

<span class="sd">        :return: The point layers within the builder</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="PlotBuilder.get_points"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StrDict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the collection of point layers in the builder.</span>

<span class="sd">        External version, returns a deepcopy.</span>

<span class="sd">        :return: The point layers within the builder</span>
<span class="sd">        :rtype: Dict[str, StrDict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">())</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_point"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_point">[docs]</a>    <span class="k">def</span> <span class="nf">remove_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes a point layer from the builder.</span>

<span class="sd">        :param name: The name of the layer to remove</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param pop: Whether to return the removed layer or not</span>
<span class="sd">        :type pop: bool</span>
<span class="sd">        :return: The removed layer (pop=True)</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">point</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLayerError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.update_point_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_point_manager">[docs]</a>    <span class="k">def</span> <span class="nf">update_point_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the manager of a point or points.</span>

<span class="sd">        The manager consists of Plotly properties.</span>
<span class="sd">        If the given name is none, all point layers will be updated.</span>

<span class="sd">        :param name: The name of the layer to update</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param updates: A dict containing updates for the layer(s)</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether to override the current properties with the new ones or not</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Other updates for the layer(s)</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_update_manager</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_update_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_point</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_point_manager"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_point_manager">[docs]</a>    <span class="k">def</span> <span class="nf">clear_point_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the manager of a point layer.</span>

<span class="sd">        If the given name is none, clears all of the point managers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_point_manager</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">updates</span><span class="o">=</span><span class="p">{},</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_point_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_point_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_point_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the data within the point layer to the data that was input at the beginning.</span>

<span class="sd">        If the given name is None, all point layers will be reset.</span>

<span class="sd">        :param name: The name of the layer to reset</span>
<span class="sd">        :type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_reset_to_odata</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_reset_to_odata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_point</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_points"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_points">[docs]</a>    <span class="k">def</span> <span class="nf">reset_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the point layer container to its original state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FIGURE FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.update_figure"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.update_figure">[docs]</a>    <span class="k">def</span> <span class="nf">update_figure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the figure properties on the spot.</span>

<span class="sd">        :param updates: A dict of properties to update the figure with</span>
<span class="sd">        :type updates: StrDict</span>
<span class="sd">        :param overwrite: Whether to overwrite existing figure properties or not</span>
<span class="sd">        :type overwrite: bool</span>
<span class="sd">        :param kwargs: Any other updates for the figure</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="n">simplify_dicts</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update_geos</span><span class="p">(</span><span class="n">updates</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;geos&#39;</span><span class="p">,</span> <span class="p">{}),</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">updates</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DATA ALTERING FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.apply_to_query"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.apply_to_query">[docs]</a>    <span class="k">def</span> <span class="nf">apply_to_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allow_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a function to the layers within a query.</span>

<span class="sd">        For advanced users and not to be used carelessly.</span>
<span class="sd">        The functions first argument must be the layer.</span>

<span class="sd">        :param name: The query of the layers to apply the function to</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param fn: The function to apply</span>
<span class="sd">        :type fn: Callable</span>
<span class="sd">        :param allow_empty: Whether to allow query arguments that retrieved empty results or not</span>
<span class="sd">        :type allow_empty: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The query submitted returned an empty result.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">layers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The query submitted returned an empty result.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vv</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The query submitted returned an empty result.&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">vv</span><span class="p">:</span>
                            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">vvv</span> <span class="ow">in</span> <span class="n">vv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vvv</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The query submitted returned an empty result.&quot;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">vvv</span><span class="p">:</span>
                                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">vvv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error when applying function to query.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lst</span></div>

<div class="viewcode-block" id="PlotBuilder.remove_empties"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.remove_empties">[docs]</a>    <span class="k">def</span> <span class="nf">remove_empties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">empty_symbol</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">add_to_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes empty entries from the hexbin layer.</span>

<span class="sd">        The empty entries may then be added to the plot as a grid.</span>

<span class="sd">        :param empty_symbol: The symbol that constitutes an empty value in the layer</span>
<span class="sd">        :type empty_symbol: Any</span>
<span class="sd">        :param add_to_plot: Whether to add the empty cells to the plot or not</span>
<span class="sd">        :type add_to_plot: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">add_to_plot</span><span class="p">:</span>
            <span class="n">empties</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">empty_symbol</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">empties</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">empties</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_grids</span><span class="p">()[</span><span class="s1">&#39;|*EMPTY*|&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">empties</span>
        <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">empty_symbol</span><span class="p">]</span></div>

    <span class="c1"># this is both a data altering, and plot altering function</span>
<div class="viewcode-block" id="PlotBuilder.logify_scale"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.logify_scale">[docs]</a>    <span class="k">def</span> <span class="nf">logify_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes the scale of the hexbin layers logarithmic.</span>

<span class="sd">        This function changes the tick values and tick text of the scale.</span>
<span class="sd">        The numerical values on the scale are the exponent of the tick text,</span>
<span class="sd">        i.e the text of 1 on the scale actually represents the value of zero,</span>
<span class="sd">        and the text of 1000 on the scale actually represents the value of 3.</span>

<span class="sd">        :param kwargs: Keyword arguments to be passed into logify functions</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;VTYPE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;STR&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The scale of a hexbin layer that is binned &quot;</span>
                            <span class="s2">&quot;based on qualitative data can not be converted into a logarithmic scale.&quot;</span><span class="p">)</span>
        <span class="n">_update_manager</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">butil</span><span class="o">.</span><span class="n">logify_scale</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="PlotBuilder.clip_layers"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clip_layers">[docs]</a>    <span class="k">def</span> <span class="nf">clip_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clip</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;sjoin&#39;</span><span class="p">,</span> <span class="n">reduce_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;intersects&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clips a query of layers to another layer.</span>
<span class="sd">        this function is experimental and may not always work as intended</span>

<span class="sd">        There are two methods for this clipping:</span>
<span class="sd">        1) sjoin -&gt; Uses GeoPandas spatial join in order to clip geometries</span>
<span class="sd">                    that (intersect, are within, contain, etc.) the geometries</span>
<span class="sd">                    acting as the clip.</span>
<span class="sd">        2) gpd  -&gt;  Uses GeoPandas clip function in order to clip geometries</span>
<span class="sd">                    to the boundary of the geometries acting as the clip.</span>

<span class="sd">        :param clip: The query for the layers that are to be clipped to another</span>
<span class="sd">        :type clip: GeoDataFrame</span>
<span class="sd">        :param to: The query for the layers that are to be used as the boundary</span>
<span class="sd">        :type to: GeoDataFrame</span>
<span class="sd">        :param method: The method to use when clipping, one of &#39;sjoin&#39;, &#39;gpd&#39;</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param reduce_first: Determines whether the geometries acting as the clip should be reduced first or not</span>
<span class="sd">        :type reduce_first: bool</span>
<span class="sd">        :param operation: The operation to apply when using sjoin (spatial join operation)</span>
<span class="sd">        :type operation: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: In the future combining the geometries of all dataframes may be useful. (geopandas overlay how=union)</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">layer</span><span class="p">:</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">reduce_first</span><span class="p">:</span>
            <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">datas</span><span class="p">)</span><span class="o">.</span><span class="n">unary_union</span><span class="p">],</span>
                                  <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">gpdhelp</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">butil</span><span class="o">.</span><span class="n">gpd_clip</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">datas</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">sjoinhelp</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">butil</span><span class="o">.</span><span class="n">sjoin_clip</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">datas</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="n">operation</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gpd&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">gpdhelp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sjoin&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">sjoinhelp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When clipping layers, the selected method must be one of [&#39;gpd&#39;, &#39;sjoin&#39;].&quot;</span><span class="p">)</span></div>

    <span class="c1"># check methods of clipping</span>
<div class="viewcode-block" id="PlotBuilder.simple_clip"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.simple_clip">[docs]</a>    <span class="k">def</span> <span class="nf">simple_clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;sjoin&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quick general clipping.</span>

<span class="sd">        This function clips the hexbin layer and grid layers to the region and outline layers.</span>
<span class="sd">        The function also clips the point layers to the hexbin, region, grid, and outline layers.</span>

<span class="sd">        :param method: The method to use when clipping, one of &#39;sjoin&#39; or &#39;gpd&#39;</span>
<span class="sd">        :type method: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clip_layers</span><span class="p">(</span><span class="s1">&#39;hexbin+grids&#39;</span><span class="p">,</span> <span class="s1">&#39;regions+outlines&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">)</span>
        <span class="c1"># self.clip_layers(&#39;hexbin+grids&#39;, &#39;outlines&#39;, method=method, operation=&#39;intersects&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_layers</span><span class="p">(</span><span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="s1">&#39;hexbin+regions+outlines+grids&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s1">&#39;within&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_remove_underlying_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">gdf</span><span class="p">:</span> <span class="n">GeoDataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the pieces of a GeoDataFrame that lie under another.</span>

<span class="sd">        :param df: The overlayed dataframe (after alteration)</span>
<span class="sd">        :type df: GeoDataFrame</span>
<span class="sd">        :param gdf: The merged underlying dataframe (after alteration)</span>
<span class="sd">        :type gdf: GeoDataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">notnull</span><span class="p">()],</span>
                              <span class="n">how</span><span class="o">=</span><span class="s1">&#39;difference&#39;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">remove_other_geometries</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gdf</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PLOT ALTERING FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">adjust_figure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">450</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">patch</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">colorbar_ypad</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">selector</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;choropleth&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="PlotBuilder.adjust_colorbar_size"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.adjust_colorbar_size">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_colorbar_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">450</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjusts the color scale position of the color bar to match the plot area size.</span>

<span class="sd">        Does not work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="PlotBuilder.adjust_opacity"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.adjust_opacity">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_opacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conforms the opacity of the color bar of the hexbin layer to an alpha value.</span>

<span class="sd">        The alpha value can be passed in as a parameter, otherwise it is taken</span>
<span class="sd">        from the marker.opacity property within the layer&#39;s manager.</span>

<span class="sd">        :param alpha: The alpha value to conform the color scale to</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>
        <span class="n">butil</span><span class="o">.</span><span class="n">opacify_colorscale</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.adjust_focus"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.adjust_focus">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_focus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hexbin&#39;</span><span class="p">,</span> <span class="n">center_on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rotation_on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">ranges_on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rot_buffer_lat</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rot_buffer_lon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                     <span class="n">buffer_lat</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">buffer_lon</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Focuses on layer(s) within the plot.</span>

<span class="sd">        Collects the geometries of the queried layers in order to</span>
<span class="sd">        obtain a boundary to focus on.</span>

<span class="sd">        In the future using a GeoSeries may be looked into for cleaner code.</span>

<span class="sd">        :param on: The query for the layer(s) to be focused on</span>
<span class="sd">        :type on: str</span>
<span class="sd">        :param center_on: Whether or not to add a center component to the focus</span>
<span class="sd">        :type center_on: bool</span>
<span class="sd">        :param rotation_on: Whether or not to add a projection rotation to the focus</span>
<span class="sd">        :type rotation_on: bool</span>
<span class="sd">        :param ranges_on: Whether or not to add a lat axis, lon axis ranges to the focus</span>
<span class="sd">        :type ranges_on: bool</span>
<span class="sd">        :param rot_buffer_lat: A number to add or subtract from the automatically calculated latitude (rotation)</span>
<span class="sd">        :type rot_buffer_lat: float</span>
<span class="sd">        :param rot_buffer_lon: A number to add or subtract from the automatically calculated longitude (rotation)</span>
<span class="sd">        :type rot_buffer_lon: float</span>
<span class="sd">        :param buffer_lat: A low and high bound to add and subtract from the lataxis range</span>
<span class="sd">        :type buffer_lat: Tuple[float, float]</span>
<span class="sd">        :param buffer_lon: A low and high bound to add and subtract from the lonaxis range</span>
<span class="sd">        :type buffer_lon: Tuple[float, float]</span>
<span class="sd">        :param validate: Whether or not to validate the ranges</span>
<span class="sd">        :type validate: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">ds</span><span class="p">:</span> <span class="n">geoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">geoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are no geometries in your query to focus on.&quot;</span><span class="p">)</span>

        <span class="n">geos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">ranges_on</span><span class="p">:</span>
            <span class="n">lonrng</span><span class="p">,</span> <span class="n">latrng</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">find_ranges_simple</span><span class="p">(</span><span class="n">geoms</span><span class="p">)</span>
            <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lataxis_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">latrng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">latrng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_lat</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lonaxis_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lonrng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lonrng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_lon</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
                <span class="n">latlow</span><span class="p">,</span> <span class="n">lathigh</span> <span class="o">=</span> <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lataxis_range&#39;</span><span class="p">]</span>
                <span class="n">lonlow</span><span class="p">,</span> <span class="n">lonhigh</span> <span class="o">=</span> <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lonaxis_range&#39;</span><span class="p">]</span>

                <span class="n">lonlowdiff</span><span class="p">,</span> <span class="n">lonhighdiff</span> <span class="o">=</span> <span class="n">get_percdiff</span><span class="p">(</span><span class="n">lonlow</span><span class="p">,</span> <span class="o">-</span><span class="mi">180</span><span class="p">),</span> <span class="n">get_percdiff</span><span class="p">(</span><span class="n">lonhigh</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
                <span class="n">latlowdiff</span><span class="p">,</span> <span class="n">lathighdiff</span> <span class="o">=</span> <span class="n">get_percdiff</span><span class="p">(</span><span class="n">latlow</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">),</span> <span class="n">get_percdiff</span><span class="p">(</span><span class="n">lathigh</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lonlowdiff</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">lonhighdiff</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lonaxis_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">latlowdiff</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">lathighdiff</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;lataxis_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">find_center_simple</span><span class="p">(</span><span class="n">geoms</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rotation_on</span><span class="p">:</span>
            <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;projection_rotation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">rot_buffer_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">rot_buffer_lon</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">center_on</span><span class="p">:</span>
            <span class="n">geos</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update_geos</span><span class="p">(</span><span class="o">**</span><span class="n">geos</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.auto_grid"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.auto_grid">[docs]</a>    <span class="k">def</span> <span class="nf">auto_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hexbin&#39;</span><span class="p">,</span> <span class="n">by_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hex_resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes a grid over the queried layers.</span>

<span class="sd">        :param on: The query for the layers to have a grid generated over them</span>
<span class="sd">        :type on: str</span>
<span class="sd">        :param by_bounds: Whether or not to treat the  geometries as a single boundary</span>
<span class="sd">        :type by_bounds: bool</span>
<span class="sd">        :param hex_resolution: The hexagonal resolution to use for the auto grid</span>
<span class="sd">        :type hex_resolution: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">generate_grid_over</span> <span class="k">if</span> <span class="n">by_bounds</span> <span class="k">else</span> <span class="n">gcg</span><span class="o">.</span><span class="n">hexify_dataframe</span>
        <span class="n">hex_resolution</span> <span class="o">=</span> <span class="n">hex_resolution</span> <span class="k">if</span> <span class="n">hex_resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_hex_resolution</span>

        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">hex_resolution</span><span class="o">=</span><span class="n">hex_resolution</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="n">helper</span><span class="p">))),</span> <span class="n">crs</span><span class="o">=</span><span class="s1">&#39;EPSG:4326&#39;</span><span class="p">)[</span>
                <span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">()[</span><span class="sa">f</span><span class="s1">&#39;|*AUTO-</span><span class="si">{</span><span class="n">on</span><span class="si">}</span><span class="s1">*|&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">grid</span><span class="p">,</span> <span class="s1">&#39;manager&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There may have been an error when generating auto grid, shapes may span too large &quot;</span>
                                 <span class="s2">&quot;of an area.&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="PlotBuilder.discretize_scale"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.discretize_scale">[docs]</a>    <span class="k">def</span> <span class="nf">discretize_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;sequential&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the color scale of the layer(s) to a discrete scale.</span>

<span class="sd">        :param scale_type: One of &#39;sequential&#39;, &#39;discrete&#39; for the type of color scale being used</span>
<span class="sd">        :type scale_type: str</span>
<span class="sd">        :param kwargs: Keyword arguments to be passed into the discretize functions</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;VTYPE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;STR&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;You can not discretize a qualitative layer.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zmin&#39;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;value_field&#39;</span><span class="p">]))</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zmax&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;value_field&#39;</span><span class="p">]))</span>
            <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">][</span><span class="s1">&#39;colorscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">discretize_cscale</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;colorscale&#39;</span><span class="p">),</span> <span class="n">scale_type</span><span class="p">,</span>
                                                                 <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RETRIEVAL/SEARCHING FUNCTIONS</span>
<span class="sd">    </span>
<span class="sd">    get_regions(), etc... could also fall under here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.search"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Query the builder for specific layer(s).</span>

<span class="sd">        Each query argument should be formatted like:</span>
<span class="sd">        &lt;regions|grids|outlines|points|main|hexbin|all&gt;</span>
<span class="sd">        OR</span>
<span class="sd">        &lt;region|grid|outline|point&gt;:&lt;name&gt;</span>

<span class="sd">        And each query argument can be separated by the &#39;+&#39; character.</span>

<span class="sd">        External version.</span>

<span class="sd">        :param query: The identifiers for the layers being searched for</span>
<span class="sd">        :type query: str</span>
<span class="sd">        :return: The result of the query</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">query</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">big_query</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">multi_query</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Query the builder for specific layer(s).</span>

<span class="sd">        Internal version, see search().</span>

<span class="sd">        :param query: The identifiers for the layers being searched for</span>
<span class="sd">        :type query: str</span>
<span class="sd">        :return: The result of the query</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sargs</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">multi_query</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_search</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">big_query</span><span class="o">=</span><span class="n">big_query</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_search</span><span class="p">(</span><span class="n">sargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">big_query</span><span class="o">=</span><span class="n">big_query</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_search</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">big_query</span><span class="o">=</span><span class="n">big_query</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sargs</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_single_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">big_query</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StrDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Query the builder for specific layers()</span>

<span class="sd">        Retrieves a query of a single argument only, see _search().</span>

<span class="sd">        :param query: The identifier for the layer(s) being searched for</span>
<span class="sd">        :type query: str</span>
<span class="sd">        :param big_query: Whether to allow the query argument to represent a collection of layers or not</span>
<span class="sd">        :type big_query: bool</span>
<span class="sd">        :return: The result of the query</span>
<span class="sd">        :rtype: StrDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">type_ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_region</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_grid</span><span class="p">,</span> <span class="n">outline</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_outline</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_point</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="s1">&#39;hexbin&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">query</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;regions&#39;</span><span class="p">,</span> <span class="s1">&#39;grids&#39;</span><span class="p">,</span> <span class="s1">&#39;outlines&#39;</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">big_query</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="k">if</span> <span class="n">query</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">[</span><span class="n">query</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BuilderQueryInvalidError</span><span class="p">(</span><span class="s2">&quot;The given query should not refer to a collection of layers.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">typer</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">_split_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BuilderQueryInvalidError</span><span class="p">(</span>
                <span class="s2">&quot;The given query should be one of [&#39;regions&#39;, &#39;grids&#39;, &#39;outlines&#39;, &#39;points&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;main&#39;, &#39;hexbin&#39;] or in the form of &#39;&lt;type&gt;:&lt;name&gt;&#39;.</span><span class="se">\n</span><span class="s2">Received: </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">type_ret</span><span class="p">[</span><span class="n">typer</span><span class="p">](</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BuilderQueryInvalidError</span><span class="p">(</span><span class="s2">&quot;The given layer type does not exist.</span><span class="se">\n</span><span class="s2">Must be one of [&#39;region&#39;, &quot;</span>
                                           <span class="sa">f</span><span class="s2">&quot;&#39;grid&#39;, &#39;outline&#39;, &#39;point&#39;].</span><span class="se">\n</span><span class="s2"> Received: </span><span class="si">{</span><span class="n">typer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">get_query_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">ds</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PLOTTING FUNCTIONS</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotBuilder.plot_regions"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.plot_regions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the region layers within the builder.</span>

<span class="sd">        All of the regions are treated as separate plot traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(&#39;adding regions to plot.&#39;)</span>
        <span class="n">mapbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoLayersError</span><span class="p">(</span><span class="n">LayerType</span><span class="o">.</span><span class="n">REGION</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">regname</span><span class="p">,</span> <span class="n">regds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_regions</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_choropleth_trace</span><span class="p">(</span>
                <span class="n">gcg</span><span class="o">.</span><span class="n">conform_geogeometry</span><span class="p">(</span><span class="n">regds</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]),</span>
                <span class="n">mapbox</span><span class="o">=</span><span class="n">mapbox</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">regds</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">DATA_PRESENT</span></div>

<div class="viewcode-block" id="PlotBuilder.plot_grids"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.plot_grids">[docs]</a>    <span class="k">def</span> <span class="nf">plot_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_underlying</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the grid layers within the builder.</span>

<span class="sd">        Merges all of the layers together, and plots it as a single plot trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grids</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoLayersError</span><span class="p">(</span><span class="n">LayerType</span><span class="o">.</span><span class="n">GRID</span><span class="p">)</span>

        <span class="n">merged</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">conform_geogeometry</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_to_query</span><span class="p">(</span><span class="s1">&#39;grids&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">layer</span><span class="p">:</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">remove_underlying</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_underlying_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">merged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_choropleth_trace</span><span class="p">(</span>
            <span class="n">merged</span><span class="p">,</span>
            <span class="n">mapbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;GRID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">DATA_PRESENT</span></div>

<div class="viewcode-block" id="PlotBuilder.plot_hexbin"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.plot_hexbin">[docs]</a>    <span class="k">def</span> <span class="nf">plot_hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the hexbin layer within the builder.</span>

<span class="sd">        If qualitative, the layer is split into uniquely labelled plot traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hexbin</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">gcg</span><span class="o">.</span><span class="n">conform_geogeometry</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

        <span class="c1"># qualitative layer</span>
        <span class="k">if</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;VTYPE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;STR&#39;</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;BEST OPTION: &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span>
            <span class="n">colorscale</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;colorscale&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">colorscale</span> <span class="o">=</span> <span class="n">get_scale</span><span class="p">(</span><span class="n">colorscale</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">sep</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">mapbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span>

            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;temp_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;temp_value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
                <span class="n">sep</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;temp_value&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>

            <span class="n">manager</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sep</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">manager</span><span class="p">[</span><span class="s1">&#39;colorscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solid_scale</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ColorScaleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If the colorscale is a map, you must provide hues for each option.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;There was no color specified for the unique option of &#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_choropleth_trace</span><span class="p">(</span>
                        <span class="n">v</span><span class="p">,</span>
                        <span class="n">mapbox</span><span class="o">=</span><span class="n">mapbox</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">showscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">manager</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sep</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> \
                                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">set</span><span class="p">):</span>
                            <span class="n">manager</span><span class="p">[</span><span class="s1">&#39;colorscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solid_scale</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">manager</span><span class="p">[</span><span class="s1">&#39;colorscale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solid_scale</span><span class="p">(</span><span class="n">colorscale</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ColorScaleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were not enough hues for all of the &quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;unique options in the layer.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;There was no color specified for the unique option of &#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;# of colors supplied: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">colorscale</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;# of colors needed: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
                        <span class="n">_prepare_choropleth_trace</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mapbox</span><span class="o">=</span><span class="n">mapbox</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">showscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                           <span class="n">text</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">manager</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ColorScaleError</span><span class="p">(</span><span class="s2">&quot;The color scale given is not valid.</span><span class="se">\n</span><span class="s2"> &quot;</span>
                                      <span class="s2">&quot;The color scale must be one of the following options:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                      <span class="s2">&quot;1) a valid Plotly color scale (string);</span><span class="se">\n</span><span class="s2">&quot;</span>
                                      <span class="s2">&quot;2) a dictionary-style collection (including hues for all unique options); or</span><span class="se">\n</span><span class="s2">&quot;</span>
                                      <span class="s2">&quot;3) a list-style collection (including hues for all unique options).&quot;</span><span class="p">)</span>
        <span class="c1"># quantitative layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;VALUE: &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;value_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_choropleth_trace</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">mapbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">text</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">DATA_PRESENT</span></div>

<div class="viewcode-block" id="PlotBuilder.plot_outlines"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.plot_outlines">[docs]</a>    <span class="k">def</span> <span class="nf">plot_outlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raise_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the outline layers within the builder.</span>

<span class="sd">        All of the outlines are treated as separate plot traces.</span>
<span class="sd">        The layers must first be converted into point-like geometries.</span>

<span class="sd">        :param raise_errors: Whether or not to throw errors upon reaching empty dataframes</span>
<span class="sd">        :type raise_errors: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoLayersError</span><span class="p">(</span><span class="n">LayerType</span><span class="o">.</span><span class="n">OUTLINE</span><span class="p">)</span>

        <span class="n">mapbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span>
        <span class="k">for</span> <span class="n">outname</span><span class="p">,</span> <span class="n">outds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_outlines</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_scattergeo_trace</span><span class="p">(</span>
                <span class="n">gcg</span><span class="o">.</span><span class="n">pointify_geodataframe</span><span class="p">(</span><span class="n">outds</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">explode</span><span class="p">(),</span>
                                          <span class="n">keep_geoms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">raise_errors</span><span class="o">=</span><span class="n">raise_errors</span><span class="p">),</span>
                <span class="n">separate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">disjoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">mapbox</span><span class="o">=</span><span class="n">mapbox</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outds</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">DATA_PRESENT</span></div>

<div class="viewcode-block" id="PlotBuilder.plot_points"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.plot_points">[docs]</a>    <span class="k">def</span> <span class="nf">plot_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the point layers within the builder.</span>

<span class="sd">        All of the point are treated as separate plot traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NoLayersError</span><span class="p">(</span><span class="n">LayerType</span><span class="o">.</span><span class="n">POINT</span><span class="p">)</span>

        <span class="n">mapbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">==</span> <span class="s1">&#39;mapbox&#39;</span>
        <span class="k">for</span> <span class="n">poiname</span><span class="p">,</span> <span class="n">poids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">_prepare_scattergeo_trace</span><span class="p">(</span>
                <span class="n">poids</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span>
                <span class="n">separate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">disjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">mapbox</span><span class="o">=</span><span class="n">mapbox</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">poiname</span><span class="p">,</span>
                                      <span class="n">text</span><span class="o">=</span><span class="n">poids</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">poids</span><span class="p">[</span><span class="s1">&#39;tfield&#39;</span><span class="p">]]</span> <span class="k">if</span> <span class="n">poids</span><span class="p">[</span><span class="s1">&#39;tfield&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                                   <span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">poids</span><span class="p">[</span><span class="s1">&#39;manager&#39;</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">DATA_PRESENT</span></div>

<div class="viewcode-block" id="PlotBuilder.set_mapbox"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.set_mapbox">[docs]</a>    <span class="k">def</span> <span class="nf">set_mapbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accesstoken</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepares the builder for a mapbox output.</span>

<span class="sd">        Sets figure.layout.mapbox_accesstoken, and plot_settings output service.</span>

<span class="sd">        :param accesstoken: A mapbox access token for the plot</span>
<span class="sd">        :type accesstoken: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_output_service</span> <span class="o">=</span> <span class="s1">&#39;mapbox&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">mapbox_accesstoken</span><span class="o">=</span><span class="n">accesstoken</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.finalize"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.finalize">[docs]</a>    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">plot_regions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_grids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_hexbin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_outlines</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_points</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">raise_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds the final plot by adding traces in order.</span>

<span class="sd">        Invokes the functions in the following order:</span>
<span class="sd">        1) plot regions</span>
<span class="sd">        2) plot grids</span>
<span class="sd">        3) plot layer</span>
<span class="sd">        4) plot outlines</span>
<span class="sd">        5) plot points</span>

<span class="sd">        In the future we should alter these functions to</span>
<span class="sd">        allow trace order implementation.</span>

<span class="sd">        :param plot_regions: Whether or not to plot region layers</span>
<span class="sd">        :type plot_regions: bool</span>
<span class="sd">        :param plot_grids: Whether or not to plot grid layers</span>
<span class="sd">        :type plot_grids: bool</span>
<span class="sd">        :param plot_hexbin: Whether or not to plot the hexbin layer</span>
<span class="sd">        :type plot_hexbin: bool</span>
<span class="sd">        :param plot_outlines: Whether or not to plot outline layers</span>
<span class="sd">        :type plot_outlines: bool</span>
<span class="sd">        :param plot_points: Whether or not to plot point layers</span>
<span class="sd">        :type plot_points: bool</span>
<span class="sd">        :param raise_errors: Whether or not to raise errors related to empty layer collections</span>
<span class="sd">        :type raise_errors: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plot_regions</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_regions</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">NoLayersError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">plot_grids</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_grids</span><span class="p">(</span><span class="n">remove_underlying</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NoLayersError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">plot_hexbin</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_hexbin</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">NoLayerError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">plot_outlines</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_outlines</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">NoLayersError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">plot_points</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_points</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">NoLayersError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span> <span class="kn">from</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="PlotBuilder.output"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.output">[docs]</a>    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">clear_figure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">crop_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">percent_retain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_original</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Outputs the figure to a filepath.</span>

<span class="sd">        The figure is output via Plotly&#39;s write_image() function.</span>
<span class="sd">        Plotly&#39;s Kaleido is required for this feature.</span>

<span class="sd">        :param filepath: The filepath to output the figure at (including filename and extension)</span>
<span class="sd">        :type filepath: str</span>
<span class="sd">        :param clear_figure: Whether or not to clear the figure after this operation</span>
<span class="sd">        :type clear_figure: bool</span>
<span class="sd">        :param crop_output: Whether or not to crop the output figure (requires that extension be pdf, PdfCropMargins must be installed)</span>
<span class="sd">        :type crop_output: bool</span>
<span class="sd">        :param percent_retain: Percentage of margins to retain from crop (requires that extension be pdf, PdfCropMargins must be installed)</span>
<span class="sd">        :type percent_retain: float, str, list</span>
<span class="sd">        :param keep_original: Whether or not to keep the original figure (requires that extension be pdf, PdfCropMargins must be installed)</span>
<span class="sd">        :type keep_original: bool</span>
<span class="sd">        :param kwargs: Keyword arguments for the write_image function</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_destination</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoFilepathError</span><span class="p">(</span><span class="s2">&quot;There must either be a filepath given directly or one stored in&quot;</span>
                                      <span class="s2">&quot; the builder&#39;s &#39;output_destination&#39; property.&quot;</span><span class="p">)</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_destination</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">write_image</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_output_location</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="k">if</span> <span class="n">clear_figure</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_figure</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">crop_output</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pdfCropMargins</span> <span class="kn">import</span> <span class="n">crop</span>
            <span class="n">newfilepath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
            <span class="n">newfilepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">newfilepath</span><span class="si">}</span><span class="s2">-cropped</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">crop_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">percent_retain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">percent_retain</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">crop_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-p4&quot;</span><span class="p">)</span>
                    <span class="n">crop_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">percent_retain</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crop_args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-p&quot;</span><span class="p">,</span> <span class="n">percent_retain</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crop_args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-p4&quot;</span><span class="p">,</span> <span class="s2">&quot;1.5&quot;</span><span class="p">,</span> <span class="s2">&quot;4.5&quot;</span><span class="p">,</span> <span class="s2">&quot;2.5&quot;</span><span class="p">,</span> <span class="s2">&quot;1.5&quot;</span><span class="p">])</span>
            <span class="n">crop_args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;-u&quot;</span><span class="p">,</span> <span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="n">newfilepath</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call to PdfCropMargins: </span><span class="si">{</span><span class="n">crop_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">crop</span><span class="p">(</span><span class="n">crop_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_original</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">newfilepath</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlotBuilder.display"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear_figure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Displays the figure.</span>

<span class="sd">        The figure is displayed via Plotly&#39;s show() function.</span>
<span class="sd">        Extensions may be needed.</span>

<span class="sd">        :param clear_figure: Whether or not to clear the figure after this operation</span>
<span class="sd">        :type clear_figure: bool</span>
<span class="sd">        :param kwargs: Keyword arguments for the show function</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clear_figure</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_figure</span><span class="p">()</span></div>

<div class="viewcode-block" id="PlotBuilder.get_plot_status"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.get_plot_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_plot_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlotStatus</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the status of the internal plot.</span>

<span class="sd">        :return: The status of the plot</span>
<span class="sd">        :rtype: PlotStatus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span></div>

<div class="viewcode-block" id="PlotBuilder.clear_figure"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.clear_figure">[docs]</a>    <span class="k">def</span> <span class="nf">clear_figure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the figure of its current data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">NO_DATA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="PlotBuilder.reset"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the builder to it&#39;s initial state.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_status</span> <span class="o">=</span> <span class="n">PlotStatus</span><span class="o">.</span><span class="n">NO_DATA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_templates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figure</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;figure&#39;</span><span class="p">))</span>
            <span class="c1"># grids will all reference this manager</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_template</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_manager</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;regions&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;grids&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;outlines&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="p">{}</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_output_service</span> <span class="o">=</span> <span class="s1">&#39;plotly&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_hex_resolution</span> <span class="o">=</span> <span class="mi">3</span></div>

<div class="viewcode-block" id="PlotBuilder.reset_data"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.reset_data">[docs]</a>    <span class="k">def</span> <span class="nf">reset_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the layers of the builder to their original state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_hexbin_data</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">NoLayerError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_region_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_grid_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_outline_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_point_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="PlotBuilder.builder_from_dict"><a class="viewcode-back" href="../../builder.html#geohexviz.builder.PlotBuilder.builder_from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">builder_from_dict</span><span class="p">(</span><span class="n">builder_dict</span><span class="p">:</span> <span class="n">StrDict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes a builder from a dictionary.</span>

<span class="sd">        :param builder_dict: The dictionary to build from</span>
<span class="sd">        :type builder_dict: StrDict</span>
<span class="sd">        :param kwargs: Keyword arguments for the builder</span>
<span class="sd">        :type kwargs: **kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="n">simplify_dicts</span><span class="p">(</span><span class="n">builder_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">figure_manager</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figure_manager&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">figure_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figure_layout&#39;</span><span class="p">,</span> <span class="p">{}),</span> <span class="n">geos</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figure_geos&#39;</span><span class="p">,</span> <span class="p">{})))</span>
        <span class="n">grid_manager</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid_manager&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">builder</span> <span class="o">=</span> <span class="n">PlotBuilder</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">update_grid_manager</span><span class="p">(</span><span class="n">grid_manager</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">update_figure</span><span class="p">(</span><span class="n">figure_manager</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">builder</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">GeoHexViz</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../builder.html">     Plot Builder Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">     Errors Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../templates.html">     Templates Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simple.html">     GeoHexSimple Package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Tony Abou Zeidan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>